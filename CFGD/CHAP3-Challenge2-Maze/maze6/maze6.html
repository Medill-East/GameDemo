<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cellular Automaton Game</title>
  <style>
    /* Add your CSS styles here */
    #gridContainer {
      display: grid;
      gap: 1px;
    }

    .cell {
      width: 30px;
      height: 30px;
      border: 1px solid black;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .roundBorder {
      border: 3px solid red;
    }

    .cell0 {
      background-color: black;
      color: white;
    }

    .cell1 {
      background-color: white;
      color: black;
    }

  </style>
</head>
<body>

  <h1>Cellular Automaton Game</h1>

  <label for="gridSize">Grid Size (N):</label>
  <input type="number" id="gridSize" min="1" value="5">

  <button onclick="initialize()">Initialize</button>
  <button onclick="nextState()">Next State</button>

  <p>Current Round: <span id="roundCount">0</span></p>

  <div id="gridContainer">
    <!-- Grid will be dynamically generated here -->
  </div>

  <script>
    // Add your JavaScript logic here
    const gridSizeInput = document.getElementById('gridSize');
    const gridContainer = document.getElementById('gridContainer');
    const roundCountDisplay = document.getElementById('roundCount');
    let gridSize = parseInt(gridSizeInput.value);
    let roundCount = 0;
    let gridState = [];

    function initialize() {
      gridSize = parseInt(gridSizeInput.value);
      roundCount = 0;
      roundCountDisplay.textContent = roundCount;
      generateGrid();
    }

    function nextState() {
      nextStateButton.removeEventListener('click', nextState); // 解绑点击事件
      roundCount++;
      roundCountDisplay.textContent = roundCount;
      console.log("Before updateGrid - Current Round:", roundCount);
      updateGrid();
      nextStateButton.addEventListener('click', nextState); // 重新绑定点击事件
    }

    // 初始化按钮点击事件
    const initializeButton = document.querySelector('button:nth-of-type(1)');
    initializeButton.addEventListener('click', initialize);

    // 下一状态按钮点击事件
    const nextStateButton = document.querySelector('button:nth-of-type(2)');
    nextStateButton.addEventListener('click', nextState);

    function generateGrid() {
    gridContainer.innerHTML = '';
    gridContainer.style.gridTemplateColumns = `repeat(${gridSize}, 30px)`;

    gridState = Array.from({ length: gridSize }, () => Array.from({ length: gridSize }, () => Math.round(Math.random())));

    for (let i = 0; i < gridSize * gridSize; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.textContent = i;
        
        // 设置边框颜色
        if (roundCount % 2 === 0 && Math.floor(i / gridSize) % 2 === 0) {
        cell.classList.add('roundBorder');
        } else if (roundCount % 2 !== 0 && Math.floor(i / gridSize) % 2 !== 0) {
        cell.classList.add('roundBorder');
        }

        // 设置填充颜色
        cell.classList.add(`cell${gridState[Math.floor(i / gridSize)][i % gridSize]}`);

        // 设置内部显示的格子索引颜色
        cell.style.color = 'yellow';

        gridContainer.appendChild(cell);
    }
    }



    function updateGrid() {
    const cells = document.querySelectorAll('.cell');
    const newGridState = gridState.map(row => row.slice()); // Clone the array

    cells.forEach((cell, index) => {
    const currentRow = Math.floor(index / gridSize);
    const isOddRound = roundCount % 2 !== 0;

    // Check if the cell belongs to the recognized rows for the current round
    if ((isOddRound && currentRow % 2 === roundCount % 2) || (!isOddRound && currentRow % 2 !== roundCount % 2)) {
        const belowIndex = index + gridSize;

        if (belowIndex < gridSize * gridSize) {
            const belowCellState = gridState[currentRow + 1][index % gridSize];

            // Update state based on current and below cell states
            newGridState[currentRow][index % gridSize] = updateCellState(currentRow, index, belowCellState);
        }
    }
});

// 新增一个函数，用于根据规则更新格子状态
function updateCellState(currentRow, currentIndex, belowCellState) {
    const aboveRow = currentRow - 1;
    const aboveCellState = aboveRow >= 0 ? gridState[aboveRow][currentIndex % gridSize] : -1;

    // Apply rules based on current and below cell states
    if (currentRow === 0 || roundCount % 2 === 0) {
        // For the top row or even round, the state remains unchanged
        return gridState[currentRow][currentIndex % gridSize];
    } else {
        // For odd round and subsequent rows
        if (belowCellState === 0) {
            // 少阴 -> 老阴
            return 0;
        } else {
            // 老阴 -> 少阳
            if (aboveCellState === 0) {
                // 老阴上阴 -> 少阳
                return 1;
            } else {
                // 老阴上阳 -> 少阳
                return 1;
            }
        }
    }
}


    // Log the updated gridState
    console.log("Updated gridState:", newGridState);

    // Update the visual representation of the grid
    cells.forEach((cell, index) => {
        cell.classList.remove('cell0', 'cell1');
        cell.classList.add(`cell${newGridState[Math.floor(index / gridSize)][index % gridSize]}`);
    });

    // Update the global gridState
    gridState = newGridState;
}

  </script>

</body>
</html>
